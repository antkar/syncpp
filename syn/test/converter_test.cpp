/*
 * Copyright 2014 Anton Karmanov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//Unit tests for EBNF-to-BNF converter.

#include <cassert>
#include <istream>
#include <memory>
#include <ostream>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

#include "core/action.h"
#include "core/bnf.h"
#include "core/concrete_bnf.h"
#include "core/converter__dec.h"
#include "core/descriptor.h"
#include "core/descriptor_type.h"
#include "core/ebnf_builder.h"
#include "core/grm_parser.h"
#include "core/grm_parser_impl.h"
#include "core/types.h"
#include "core/util_mptr.h"
#include "core/util_string.h"

#include "unittest.h"

namespace ns = synbin;
namespace ebnf = ns::ebnf;
namespace prs = ns::grm_parser;
namespace types = ns::types;
namespace util = ns::util;

using std::unique_ptr;

using util::MPtr;
using util::String;

using ns::ConcreteBNF;

namespace {

	typedef ns::ConversionResult ConvRes;
	typedef unique_ptr<ConvRes> ConvResAutoPtr;

	typedef ConcreteBNF::Sym ConcreteSym;
	typedef ConcreteBNF::Nt ConcreteNt;
	typedef ConcreteBNF::Tr ConcreteTr;
	typedef ConcreteBNF::Pr ConcretePr;

	typedef std::vector<const ConcreteSym*> ConcreteSymVector;
	typedef std::vector<const ConcreteNt*> ConcreteNtVector;
	typedef std::vector<const ConcretePr*> ConcretePrVector;

	//Parses the given grammar, returns the conversion result.
	unique_ptr<ConvRes> process_grammar(const char* grammar_text) {
		std::istringstream in(grammar_text);
		util::String file_name("test");
		unique_ptr<ns::GrammarParsingResult> parsing_result = prs::parse_grammar(in, file_name);
		unique_ptr<ns::GrammarBuildingResult> building_result =
			ns::EBNF_Builder::build(false, std::move(parsing_result));

		unique_ptr<ConvRes> converting_result = ns::convert_EBNF_to_BNF(false, std::move(building_result));
		return converting_result;
	}

	void check_user_nts(const ConvRes& conv_res, const char* expected) {
		std::string actual;

		const ConcreteBNF* bnf = conv_res.get_bnf_grammar();
		const ConcreteNtVector& nts = bnf->get_nonterminals();
		for (std::size_t i = 0, n = nts.size(); i < n; ++i) {
			const ConcreteNt* nt = nts[i];
			const ns::NtDescriptor* desc = nt->get_nt_obj().get();
			if (const ns::UserNtDescriptor* user_desc = dynamic_cast<const ns::UserNtDescriptor*>(desc)) {
				actual += (actual.empty() ? "" : " ") + user_desc->get_name().str();
			} else {
				assert(dynamic_cast<const ns::AutoNtDescriptor*>(desc));
			}
		}

		assertEquals(expected, actual);
	}

	const ConcreteNt* find_nt(const ConvRes& conv_res, const char* name) {
		const ConcreteBNF* bnf = conv_res.get_bnf_grammar();
		const ConcreteNtVector& nts = bnf->get_nonterminals();
		for (std::size_t i = 0, n = nts.size(); i < n; ++i) {
			const ConcreteNt* nt = nts[i];
			const ns::NtDescriptor* desc = nt->get_nt_obj().get();
			if (const ns::UserNtDescriptor* user_desc = dynamic_cast<const ns::UserNtDescriptor*>(desc)) {
				if (user_desc->get_name().str() == name) {
					return nt;
				}
			}
		}
		failMsg("Nt not found: '" + std::string(name) + "'");
		throw std::logic_error("illegal state");
	}

	//
	//dump_* functions. Used to convert BNF grammar objects to string, what allows to compare the BNF grammar
	//generated by the EBNF-to-BNF converter with the correct grammar.
	//

	void dump_part_class_type(std::ostream& out, const ns::PartClassTypeDescriptor* type) {
		std::vector<String> attrs;
		out << "p";
	}

	void dump_type(std::ostream& out, const ns::TypeDescriptor* type) {
		out << "{";
		if (dynamic_cast<const ns::VoidTypeDescriptor*>(type)) {
			out << "void";
		} else if (const ns::ClassTypeDescriptor* type1 = dynamic_cast<const ns::ClassTypeDescriptor*>(type)) {
			out << "c:" << type1->get_class_name();
		} else if (const ns::PartClassTypeDescriptor* type1 = dynamic_cast<const ns::PartClassTypeDescriptor*>(type)) {
			dump_part_class_type(out, type1);
		} else if (const ns::ListTypeDescriptor* type1 = dynamic_cast<const ns::ListTypeDescriptor*>(type)) {
			out << "ls:";
			dump_type(out, type1->get_element_type().get());
		} else if (const ns::PrimitiveTypeDescriptor* type1 = dynamic_cast<const ns::PrimitiveTypeDescriptor*>(type)) {
			const types::PrimitiveType* ptype = type1->get_primitive_type();
			if (const types::UserPrimitiveType* ptype1 = dynamic_cast<const types::UserPrimitiveType*>(ptype)) {
				out << "u:" << ptype1->get_name();
			} else {
				const types::SystemPrimitiveType* ptype2 = dynamic_cast<const types::SystemPrimitiveType*>(ptype);
				assert(ptype2);
				out << "s:" << ptype2->get_name();
			}
		} else {
			throw "illegal state";
		}
		out << "}";
	}

	void dump_class_action(std::ostream& out, const ns::AbstractClassAction* action) {
		const char* sep = "";
		out << "(";
		
		const ns::ActionDefs::AttributeVector& attributes = action->get_attributes();
		for (std::size_t i = 0, n = attributes.size(); i < n; ++i) {
			const ns::ActionDefs::AttributeField& attr = attributes[i];
			out << sep << attr.m_name << "=" << attr.m_offset;
			sep = " ";
		}

		const ns::ActionDefs::PartClassVector& part_classes = action->get_part_classes();
		for (std::size_t i = 0, n = part_classes.size(); i < n; ++i) {
			const ns::ActionDefs::PartClassField& part_class = part_classes[i];
			out << sep;
			dump_part_class_type(out, part_class.m_part_class_type.get());
			out << "=" << part_class.m_offset;
			sep = " ";
		}

		const ns::ActionDefs::ClassVector& classes = action->get_classes();
		for (std::size_t i = 0, n = classes.size(); i < n; ++i) {
			const ns::ActionDefs::ClassField& cls = classes[i];
			out << sep << "this=" << cls.m_offset;
			sep = " ";
		}

		out << ")";
	}

	void dump_action(std::ostream& out, const ns::Action* action) {
		out << "[";
		if (dynamic_cast<const ns::VoidAction*>(action)) {
			out << "void";
		} else if (dynamic_cast<const ns::CopyAction*>(action)) {
			out << "copy";
		} else if (const ns::CastAction* action1 = dynamic_cast<const ns::CastAction*>(action)) {
			out << "cast:";
			dump_type(out, action1->get_result_type().get());
			out << ":";
			dump_type(out, action1->get_actual_type().get());
		} else if (const ns::ClassAction* action1 = dynamic_cast<const ns::ClassAction*>(action)) {
			out << "c";
			dump_class_action(out, action1);
		} else if (const ns::PartClassAction* action1 = dynamic_cast<const ns::PartClassAction*>(action)) {
			out << "p";
			dump_class_action(out, action1);
		} else if (const ns::ResultAndAction* action1 = dynamic_cast<const ns::ResultAndAction*>(action)) {
			out << "r:" << action1->get_result_index();
		} else if (dynamic_cast<const ns::FirstListAction*>(action)) {
			out << "lstf";
		} else if (const ns::NextListAction* action1 = dynamic_cast<const ns::NextListAction*>(action)) {
			out << (action1->is_separator() ? "lsts" : "lstn");
		} else if (const ns::ConstAction* action1 = dynamic_cast<const ns::ConstAction*>(action)) {
			out << "<";
			action1->get_const_expr()->print(out);
			out << ">";
		} else {
			throw "illegal state";
		}
		out << "]";
	}

	typedef std::map<int, std::size_t> AutoNtMap;

	void dump_auto_nt(
		std::ostream& out,
		const ConcreteNt* nt,
		const ns::AutoNtDescriptor* desc,
		AutoNtMap& auto_nt_map);

	void dump_symbol(std::ostream& out, const ConcreteSym* sym, AutoNtMap& auto_nt_map) {
		if (const ConcreteNt* nt = sym->as_nt()) {
			MPtr<const ns::NtDescriptor> desc = nt->get_nt_obj();
			if (const ns::UserNtDescriptor* desc1 = dynamic_cast<const ns::UserNtDescriptor*>(desc.get())) {
				out << desc1->get_name();
			} else {
				const ns::AutoNtDescriptor* desc2 = dynamic_cast<const ns::AutoNtDescriptor*>(desc.get());
				assert(desc2);
				dump_auto_nt(out, nt, desc2, auto_nt_map);
			}
		} else {
			const ConcreteTr* tr = sym->as_tr();
			assert(tr);
			MPtr<const ns::TrDescriptor> desc = tr->get_tr_obj();
			if (const ns::NameTrDescriptor* desc1 = dynamic_cast<const ns::NameTrDescriptor*>(desc.get())) {
				out << desc1->get_name();
			} else {
				const ns::StrTrDescriptor* desc2 = dynamic_cast<const ns::StrTrDescriptor*>(desc.get());
				assert(desc2);
				out << "'";
				out << desc2->get_str();
				out << "'";
			}
		}
	}

	void dump_production(
		std::ostream& out,
		const ConcretePr* pr,
		const std::string& nt_type_str,
		AutoNtMap& auto_nt_map)
	{
		const ConcreteSymVector& elements = pr->get_elements();
		for (std::size_t i = 0, n = elements.size(); i < n; ++i) {
			const ConcreteSym* sym = elements[i];
			out << " ";
			dump_symbol(out, sym, auto_nt_map);
		}

		out << " ";

		std::ostringstream type_out;
		const ns::TypeDescriptor* type = pr->get_pr_obj()->get_type().get();
		dump_type(type_out, type);
		const std::string& type_str = type_out.str();

		std::ostringstream action_out;
		const ns::Action* action = pr->get_pr_obj()->get_action().get();
		dump_action(action_out, action);
		const std::string& action_str = action_out.str();

		if ("[void]" == action_str) {
			assert("{void}" == type_str);
		} else {
			assert(nt_type_str == type_str);
		}
		out << action_str;
	}

	void dump_nt_productions(
		std::ostream& out,
		const ConcreteNt* nt,
		const std::string& type_str,
		AutoNtMap& auto_nt_map)
	{
		const ConcretePrVector& prs = nt->get_productions();
		for (std::size_t i = 0, n = prs.size(); i < n; ++i) {
			const ConcretePr* pr = prs[i];
			out << (i == 0 ? "" : " |");
			dump_production(out, pr, type_str, auto_nt_map);
		}
	}

	void dump_nt(std::ostream& out, const ConcreteNt* nt, AutoNtMap& auto_nt_map);

	void dump_auto_nt(
		std::ostream& out,
		const ConcreteNt* nt,
		const ns::AutoNtDescriptor* desc,
		AutoNtMap& auto_nt_map)
	{
		out << "A:";
		if (auto_nt_map.find(nt->get_nt_index()) == auto_nt_map.end()) {
			std::size_t next_index = auto_nt_map.size();
			auto_nt_map[nt->get_nt_index()] = next_index;
			out << next_index;
			out << "(";
			dump_nt(out, nt, auto_nt_map);
			out << ")";
		} else {
			out << auto_nt_map[nt->get_nt_index()];
		}
	}

	void dump_nt(std::ostream& out, const ConcreteNt* nt, AutoNtMap& auto_nt_map) {
		MPtr<const ns::NtDescriptor> desc = nt->get_nt_obj();
		MPtr<const ns::TypeDescriptor> type = desc->get_type();

		std::ostringstream type_out;
		dump_type(type_out, type.get());
		const std::string& type_str = type_out.str();
		out << type_str;

		out << " :";
		dump_nt_productions(out, nt, type_str, auto_nt_map);
	}

	void check_nt_dump(const ConvRes& conv_res, const char* name, const char* expected_dump) {
		const ConcreteNt* nt = find_nt(conv_res, name);
		std::ostringstream out;
		AutoNtMap auto_nt_map;
		
		const ns::UserNtDescriptor* desc = dynamic_cast<const ns::UserNtDescriptor*>(nt->get_nt_obj().get());
		assert(desc);
		out << desc->get_name();
		
		dump_nt(out, nt, auto_nt_map);
		const std::string actual_dump = out.str();
		assertEquals(expected_dump, actual_dump);
	}

}

namespace {

	void check_nt(const char* grammar_text, const char* expected_dump, const char* nts = "X", const char* nt = "X") {
		std::string str =
			"%token T; %token T1{tp}; %token T2{tp}; %token T3{tp}; %token T4{tp}; "
			"%token TA1{tp1}; %token TA2{tp2}; %token TA3{tp3};";
		str += grammar_text;
		ConvResAutoPtr conv_res = process_grammar(str.c_str());
		check_user_nts(*conv_res, nts);
		check_nt_dump(*conv_res, nt, expected_dump);
	}

}

namespace {//anonymous

TEST(nt_empty) {
	check_nt("X : ;", "X{void} : [void]");
}

TEST(pr_empty) {
	check_nt("X : T | ;", "X{void} : T [void] | [void]");
}

TEST(sym_empty) {
	check_nt("X : T () ;", "X{void} : T A:0({void} : [void]) [void]");
}

TEST(nt_const) {
	check_nt("X : <35> ;", "X{s:const_int} : [<35>]");
}

TEST(pr_const) {
	check_nt("X : T | <35> ;", "X{s:const_int} : T [void] | [<35>]");
}

TEST(sym_const) {
	check_nt("X : T %this=<35> ;", "X{s:const_int} : T A:0({s:const_int} : [<35>]) [r:1]");
}

TEST(nt_string) {
	check_nt("X : \"hello\" ;", "X{void} : 'hello' [void]");
}

TEST(pr_string) {
	check_nt("X : T | \"hello\" ;", "X{void} : T [void] | 'hello' [void]");
}

TEST(sym_string) {
	check_nt("X : T \"hello\" ;", "X{void} : T 'hello' [void]");
}

TEST(nt_name_tr_void) {
	check_nt("X : T ;", "X{void} : T [void]");
}

TEST(nt_name_tr_typed) {
	check_nt("%token TT {str}; X : TT ;", "X{u:str} : TT [copy]");
}

TEST(pr_name_tr_typed) {
	check_nt("%token TT {str}; X : T | TT ;", "X{u:str} : T [void] | TT [copy]");
}

TEST(sym_name_tr_typed) {
	check_nt("%token TT {str}; X : T %this=TT ;", "X{u:str} : T TT [r:1]");
}

TEST(nt_name_nt) {
	ConvResAutoPtr conv_res = process_grammar("X : Y ; Y : ;");
	check_user_nts(*conv_res, "X Y");
	check_nt_dump(*conv_res, "X", "X{void} : Y [void]");
	check_nt_dump(*conv_res, "Y", "Y{void} : [void]");
}

TEST(nt_cast_same_primitive) {
	check_nt("X : {tp}(T1) ;", "X{u:tp} : T1 [copy]");
}

TEST(nt_cast_native_const) {
	check_nt("X : {tp}(<aaa>) ;", "X{u:tp} : [<aaa>]");
}

TEST(nt_cast_same_class) {
	check_nt("X : {X}({X}) ;", "X{c:X} : [c()]");
}

TEST(nt_cast_different_class) {
	check_nt("X : {X}({Y}) ;", "X{c:X} : A:0({c:Y} : [c()]) [cast:{c:X}:{c:Y}]");
}

TEST(pr_cast_different_class) {
	check_nt("X : T | {X}({Y}) ;", "X{c:X} : T [void] | A:0({c:Y} : [c()]) [cast:{c:X}:{c:Y}]");
}

TEST(sym_cast_different_class) {
	check_nt("X : T %this={X}({Y}) ;", "X{c:X} : T A:0({c:X} : A:1({c:Y} : [c()]) [cast:{c:X}:{c:Y}]) [r:1]");
}

TEST(nt_cast_nt_same_primitive) {
	check_nt("X{tp} : (T1) ;", "X{u:tp} : T1 [copy]");
}

TEST(nt_cast_nt_native_const) {
	check_nt("%type tp; X{tp} : (<aaa>) ;", "X{u:tp} : [<aaa>]");
}

TEST(nt_cast_nt_same_class) {
	check_nt("X{X} : {X} ;", "X{c:X} : [c()]");
}

TEST(nt_cast_nt_different_class) {
	check_nt("X{X} : {Y} ;", "X{c:X} : A:0({c:Y} : [c()]) [cast:{c:X}:{c:Y}]");
}

TEST(nt_attr_const) {
	check_nt("X : a=<5> ;", "X{c:X} : A:0({s:const_int} : [<5>]) [c(a=0)]");
}

TEST(nt_attr_token) {
	check_nt("X : a=T1 ;", "X{c:X} : T1 [c(a=0)]");
}

TEST(pr_attr_token) {
	check_nt("X : T | a=T1 ;", "X{c:X} : T [void] | T1 [c(a=0)]");
}

TEST(sym_attr_token) {
	check_nt("X : T a=T1 ;", "X{c:X} : T T1 [c(a=1)]");
}

TEST(nt_attr_nt) {
	ConvResAutoPtr conv_res = process_grammar("X : a=Y ; Y : {Y} ;");
	check_user_nts(*conv_res, "X Y");
	check_nt_dump(*conv_res, "X", "X{c:X} : Y [c(a=0)]");
	check_nt_dump(*conv_res, "Y", "Y{c:Y} : [c()]");
}

TEST(nt_attr_or_token_token) {
	check_nt("X : a=(T1|T2) ;", "X{c:X} : A:0({u:tp} : T1 [copy] | T2 [copy]) [c(a=0)]");
}

TEST(nt_this_const) {
	check_nt("X : %this=<5> ;", "X{s:const_int} : [<5>]");
}

TEST(nt_this_token) {
	check_nt("X : %this=T1 ;", "X{u:tp} : T1 [copy]");
}

TEST(pr_this_token) {
	check_nt("X : T | %this=T1 ;", "X{u:tp} : T [void] | T1 [copy]");
}

TEST(sym_this_token) {
	check_nt("X : T %this=T1 ;", "X{u:tp} : T T1 [r:1]");
}

TEST(nt_this_nt) {
	ConvResAutoPtr conv_res = process_grammar("X : %this=Y ; Y : {Y} ;");
	check_user_nts(*conv_res, "X Y");
	check_nt_dump(*conv_res, "X", "X{c:X} : A:0({c:Y} : Y [copy]) [cast:{c:X}:{c:Y}]");
	check_nt_dump(*conv_res, "Y", "Y{c:Y} : [c()]");
}

TEST(nt_this_or_token_token) {
	check_nt("X : %this=(T1|T2) ;", "X{u:tp} : T1 [copy] | T2 [copy]");
}

TEST(nt_zero_many_token) {
	check_nt("X : T1* ;", "X{ls:{u:tp}} : A:0({ls:{u:tp}} : A:0 T1 [lstn] | T1 [lstf]) [copy] | [void]");
}

TEST(pr_zero_many_token) {
	check_nt("X : T | T1* ;",
		"X{ls:{u:tp}} : T [void] | A:0({ls:{u:tp}} : A:1({ls:{u:tp}} : "
		"A:1 T1 [lstn] | T1 [lstf]) [copy] | [void]) [copy]");
}

TEST(sym_zero_many_token) {
	check_nt("X : T %this=T1* ;",
		"X{ls:{u:tp}} : T A:0({ls:{u:tp}} : A:1({ls:{u:tp}} : A:1 T1 [lstn] | T1 [lstf]) [copy] | [void]) [r:1]");
}

TEST(nt_zero_many_sep_token) {
	check_nt("X : (T1 : \",\")* ;", "X{ls:{u:tp}} : A:0({ls:{u:tp}} : A:0 ',' T1 [lsts] | T1 [lstf]) [copy] | [void]");
}

TEST(nt_one_many_token) {
	check_nt("X : T1+ ;", "X{ls:{u:tp}} : X T1 [lstn] | T1 [lstf]");
}

TEST(pr_one_many_token) {
	check_nt("X : T | T1+ ;", "X{ls:{u:tp}} : T [void] | A:0({ls:{u:tp}} : A:0 T1 [lstn] | T1 [lstf]) [copy]");
}

TEST(sym_one_many_token) {
	check_nt("X : T %this=T1+ ;", "X{ls:{u:tp}} : T A:0({ls:{u:tp}} : A:0 T1 [lstn] | T1 [lstf]) [r:1]");
}

TEST(nt_one_many_sep_token) {
	check_nt("X : (T1 : \",\")+ ;", "X{ls:{u:tp}} : X ',' T1 [lsts] | T1 [lstf]");
}

TEST(nt_or_token_token) {
	check_nt("X : T1 | T2 ;", "X{u:tp} : T1 [copy] | T2 [copy]");
}

TEST(pr_or_token_token) {
	check_nt("X : T | (T1 | T2) ;", "X{u:tp} : T [void] | A:0({u:tp} : T1 [copy] | T2 [copy]) [copy]");
}

TEST(sym_or_token_token) {
	check_nt("X : T %this=(T1 | T2) ;", "X{u:tp} : T A:0({u:tp} : T1 [copy] | T2 [copy]) [r:1]");
}

TEST(nt_zero_one_token) {
	check_nt("X : T1? ;", "X{u:tp} : T1 [copy] | [void]");
}

TEST(pr_zero_one_token) {
	check_nt("X : T | T1? ;", "X{u:tp} : T [void] | A:0({u:tp} : T1 [copy] | [void]) [copy]");
}

TEST(sym_zero_one_token) {
	check_nt("X : T %this=T1? ;", "X{u:tp} : T A:0({u:tp} : T1 [copy] | [void]) [r:1]");
}

TEST(nt_and_void_tokens) {
	check_nt("X : T1 T2 T3 ;", "X{void} : T1 T2 T3 [void]");
}

TEST(pr_and_void_tokens) {
	check_nt("X : T | (T1 T2 T3) ;", "X{void} : T [void] | T1 T2 T3 [void]");
}

TEST(sym_and_void_tokens) {
	check_nt("X : T (T1 T2 T3) ;", "X{void} : T A:0({void} : T1 T2 T3 [void]) [void]");
}

TEST(nt_and_void_nts) {
	check_nt("X : N1 N2 N3 ; N1:; N2:; N3:;", "X{void} : N1 N2 N3 [void]", "X N1 N2 N3");
}

TEST(nt_and_class_empty_tokens) {
	check_nt("X : T1 T2 T3 {C} ;", "X{c:X} : A:0({c:C} : T1 T2 T3 [c()]) [cast:{c:X}:{c:C}]");
}

TEST(nt_and_attrs_tokens) {
	check_nt("X : a=T1 b=T2 c=T3 ;", "X{c:X} : T1 T2 T3 [c(a=0 b=1 c=2)]");
}

TEST(nt_and_class_attrs_tokens) {
	check_nt("X : a=T1 b=T2 c=T3 {C} ;", "X{c:X} : A:0({c:C} : T1 T2 T3 [c(a=0 b=1 c=2)]) [cast:{c:X}:{c:C}]");
}

TEST(nt_and_this_tokens) {
	check_nt("X : TA1 %this=TA2 TA3 ;", "X{u:tp2} : TA1 TA2 TA3 [r:1]");
}

TEST(nt_and_sub_this) {
	check_nt("X : TA1 (%this=TA2) TA3 ;", "X{u:tp2} : TA1 TA2 TA3 [r:1]");
}

TEST(nt_and_sub_attr) {
	check_nt("X : TA1 (a=TA2) TA3 ;", "X{c:X} : TA1 TA2 TA3 [c(a=1)]");
}

TEST(nt_and_sub_attr_sub_attr) {
	check_nt("X : (a=TA1) TA2 (c=TA3) ;", "X{c:X} : TA1 TA2 TA3 [c(a=0 c=2)]");
}

TEST(nt_and_sub_attr_or_attr) {
	check_nt("X : (a=TA1 | a=TA2) TA3 ;", "X{c:X} : A:0({c:X} : TA1 [c(a=0)] | TA2 [c(a=0)]) TA3 [c(this=0)]");
}

TEST(nt_and_sub_attr_or_another_attr) {
	check_nt("X : (a=TA1 | b=TA2) TA3 ;", "X{c:X} : A:0({c:X} : TA1 [c(a=0)] | TA2 [c(b=0)]) TA3 [c(this=0)]");
}

TEST(nt_and_sub_attr_or_attr_attr) {
	check_nt("X : (a=TA1 | a=TA2) c=TA3 ;", "X{c:X} : A:0({p} : TA1 [p(a=0)] | TA2 [p(a=0)]) TA3 [c(c=1 p=0)]");
}

TEST(nt_and_sub_attr_or_another_attr_attr) {
	check_nt("X : (a=TA1 | b=TA2) c=TA3 ;", "X{c:X} : A:0({p} : TA1 [p(a=0)] | TA2 [p(b=0)]) TA3 [c(c=1 p=0)]");
}

TEST(implicit_cast) {
	check_nt("X : {X1} | {X2} | {X3} ;",
		"X{c:X} : A:0({c:X1} : [c()]) [cast:{c:X}:{c:X1}] "
		"| A:1({c:X2} : [c()]) [cast:{c:X}:{c:X2}] | A:2({c:X3} : [c()]) [cast:{c:X}:{c:X3}]");
}

//and(this)
TEST(and_this) {
	check_nt("X : T1 %this=T2 T3 ;", "X{u:tp} : T1 T2 T3 [r:1]");
}

//and(or(this))
TEST(and_or_this) {
	check_nt("X : T1 (%this=T2 | T3) T4 ;", "X{u:tp} : T1 A:0({u:tp} : T2 [copy] | T3 [void]) T4 [r:1]");
}

//and(zero-one(this))
TEST(and_zero_one_this) {
	check_nt("X : T1 (%this=T2)? T3 ;", "X{u:tp} : T1 A:0({u:tp} : T2 [copy] | [void]) T3 [r:1]");
}

//and(and(this))
TEST(and_and_this) {
	check_nt("X : T1 (TA1 %this=T2 TA2) T3 ;", "X{u:tp} : T1 A:0({u:tp} : TA1 T2 TA2 [r:1]) T3 [r:1]");
}

//and(or(or(this)))
TEST(and_or_or_this) {
	check_nt("X : TA1 ((%this=T1 | T2) | T3) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T1 [copy] | T2 [void]) [copy] | T3 [void]) TA2 [r:1]");
}

//and(or(zero-one(this)))
TEST(and_or_zero_one_this) {
	check_nt("X : TA1 ((%this=T1)? | T2) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T1 [copy] | [void]) [copy] | T2 [void]) TA2 [r:1]");
}

//and(or(and(this)))
TEST(and_or_and_this) {
	check_nt("X : TA1 ((TA3 %this=T2) | T3) TA2 ;", "X{u:tp} : TA1 A:0({u:tp} : TA3 T2 [r:1] | T3 [void]) TA2 [r:1]");
}

//and(or(and(this))) #2
TEST(and_or_and_this2) {
	check_nt("X : TA1 ((TA3 %this=T2) | TA1) TA2 ;", "X{u:tp} : TA1 A:0({u:tp} : TA3 T2 [r:1] | TA1 [void]) TA2 [r:1]");
}

//and(zero-one(or(this)))
TEST(and_zero_one_or_this) {
	check_nt("X : TA1 (%this=T2 | TA3)? TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T2 [copy] | TA3 [void]) [copy] | [void]) TA2 [r:1]");
}

//and(zero-one(zero-one(this)))
TEST(and_zero_one_zero_one_this) {
	check_nt("X : TA1 ((%this=T2)?)? TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T2 [copy] | [void]) [copy] | [void]) TA2 [r:1]");
}

//and(zero-one(and(this)))
TEST(and_zero_one_and_this) {
	check_nt("X : TA1 (T1 %this=T2 T3)? TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : T1 T2 T3 [r:1] | [void]) TA2 [r:1]");
}

//and(and(or(this)))
TEST(and_and_or_this) {
	check_nt("X : TA1 (T1 (%this=T2 | TA3) T3) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : T1 A:1({u:tp} : T2 [copy] | TA3 [void]) T3 [r:1]) TA2 [r:1]");
}

//and(and(zero-one(this)))
TEST(and_and_zero_one_this) {
	check_nt("X : TA1 (T1 (%this=T2)? T3) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : T1 A:1({u:tp} : T2 [copy] | [void]) T3 [r:1]) TA2 [r:1]");
}

//and(and(and(this)))
TEST(and_and_and_this) {
	check_nt("X : TA1 (T1 (T T %this=T2) T3) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : T1 A:1({u:tp} : T T T2 [r:2]) T3 [r:1]) TA2 [r:1]");
}

//and(or(this,this)))
TEST(and_or_this_this) {
	check_nt("X : TA1 TA3 (%this=T1 | %this=T2) TA2 ;", "X{u:tp} : TA1 TA3 A:0({u:tp} : T1 [copy] | T2 [copy]) TA2 [r:2]");
}

//and(or(this,or(this)))
TEST(and_or_this_or_this) {
	check_nt("X : TA1 (%this=T1 | (%this=T2 | TA3)) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : T1 [copy] | A:1({u:tp} : T2 [copy] | TA3 [void]) [copy]) TA2 [r:1]");
}

//and(or(this,zero-one(this)))
TEST(and_or_this_zero_one_this) {
	check_nt("X : TA1 (%this=T1 | (%this=T2)?) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : T1 [copy] | A:1({u:tp} : T2 [copy] | [void]) [copy]) TA2 [r:1]");
}

//and(or(this,and(this)))
TEST(and_or_this_and_this) {
	check_nt("X : TA1 (%this=T1 | %this=T2 T3) TA2 ;", "X{u:tp} : TA1 A:0({u:tp} : T1 [copy] | T2 T3 [r:0]) TA2 [r:1]");
}

//and(or(or(this),or(this)))
TEST(and_or_or_this_or_this) {
	check_nt("X : TA1 ((%this=T1 | T1) | (%this=T2 | T3)) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T1 [copy] | T1 [void]) [copy] "
		"| A:2({u:tp} : T2 [copy] | T3 [void]) [copy]) TA2 [r:1]");
}

//and(or(or(this),zero-one(this)))
TEST(and_or_or_this_zero_one_this) {
	check_nt("X : TA1 ((%this=T1 | T1) | (%this=T2)?) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T1 [copy] | T1 [void]) [copy] "
		"| A:2({u:tp} : T2 [copy] | [void]) [copy]) TA2 [r:1]");
}

//and(or(or(this),and(this)))
TEST(and_or_or_this_and_this) {
	check_nt("X : TA1 ((%this=T1 | TA3) | (T T T %this=T2 T)) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T1 [copy] | TA3 [void]) [copy] | T T T T2 T [r:3]) TA2 [r:1]");
}

//and(or(zero-one(this),zero-one(this)))
TEST(and_or_zero_one_this_zero_one_this) {
	check_nt("X : TA1 ((%this=T1)? | (%this=T2)?) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T1 [copy] | [void]) [copy] "
		"| A:2({u:tp} : T2 [copy] | [void]) [copy]) TA2 [r:1]");
}

//and(or(zero-one(this),and(this)))
TEST(and_or_zero_one_this_and_this) {
	check_nt("X : TA1 ((%this=T1)? | (T %this=T2 T T)) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : A:1({u:tp} : T1 [copy] | [void]) [copy] | T T2 T T [r:1]) TA2 [r:1]");
}

//and(or(and(this),and(this)))
TEST(and_or_and_this_and_this) {
	check_nt("X : TA1 ((%this=T1 TA3) | (T1 T2 TA3 %this=T2 T T3)) TA2 ;",
		"X{u:tp} : TA1 A:0({u:tp} : T1 TA3 [r:0] | T1 T2 TA3 T2 T T3 [r:3]) TA2 [r:1]");
}

//and(attr)
TEST(and_attr) {
	check_nt("X : T TA1 T a=T1 T TA3 TA2 ;", "X{c:X} : T TA1 T T1 T TA3 TA2 [c(a=3)]");
}

//and(or(attr))
TEST(and_or_attr) {
	check_nt("X : T TA1 (a=T1 | T) TA3 TA2 ;", "X{c:X} : T TA1 A:0({u:tp} : T1 [copy] | T [void]) TA3 TA2 [c(a=2)]");
}

//and(or(or(attr))
TEST(and_or_or_attr) {
	check_nt("X : T TA1 (T | (a=T1 | T2)) TA2 ;",
		"X{c:X} : T TA1 A:0({u:tp} : T [void] | A:1({u:tp} : T1 [copy] | T2 [void]) [copy]) TA2 [c(a=2)]");
}

//and(or(zero-one(attr))
TEST(and_or_zero_one_attr) {
	check_nt("X : TA1 (T | (a=T1)?) TA2 ;",
		"X{c:X} : TA1 A:0({u:tp} : T [void] | A:1({u:tp} : T1 [copy] | [void]) [copy]) TA2 [c(a=1)]");
}

//and(or(and-attr(attr))
TEST(and_or_and_attr_attr) {
	check_nt("X : TA1 (T | (T1 a=T2 T3)) TA2 ;", "X{c:X} : TA1 A:0({u:tp} : T [void] | T1 T2 T3 [r:1]) TA2 [c(a=1)]");
}

//and(zero-one(attr))
TEST(and_zero_one_attr) {
	check_nt("X : TA1 (a=T3)? TA2 ;", "X{c:X} : TA1 A:0({u:tp} : T3 [copy] | [void]) TA2 [c(a=1)]");
}

//and(zero-one(or(attr)))
TEST(and_zero_one_or_attr) {
	check_nt("X : TA1 ((a=T3 | TA3))? TA2 ;",
		"X{c:X} : TA1 A:0({u:tp} : A:1({u:tp} : T3 [copy] | TA3 [void]) [copy] | [void]) TA2 [c(a=1)]");
}

//and(zero-one(zero-one(attr)))
TEST(and_zero_one_zero_one_attr) {
	check_nt("X : TA1 ((a=T3)?)? TA2 ;",
		"X{c:X} : TA1 A:0({u:tp} : A:1({u:tp} : T3 [copy] | [void]) [copy] | [void]) TA2 [c(a=1)]");
}

//and(zero-one(and-attr(attr)))
TEST(and_zero_one_and_attr) {
	check_nt("X : TA1 (T a=T3 T T)? TA2 ;", "X{c:X} : TA1 A:0({u:tp} : T T3 T T [r:1] | [void]) TA2 [c(a=1)]");
}

//and(and-attr(attr))
TEST(and_and_attr) {
	check_nt("X : TA1 (T a=T3 T T)? TA2 ;", "X{c:X} : TA1 A:0({u:tp} : T T3 T T [r:1] | [void]) TA2 [c(a=1)]");
}

//and(and-attr(or(attr)))
TEST(and_and_or_attr) {
	check_nt("X : TA1 (T1 T2 (a=T3 | T)) TA2 ;",
		"X{c:X} : TA1 A:0({u:tp} : T1 T2 A:1({u:tp} : T3 [copy] | T [void]) [r:2]) TA2 [c(a=1)]");
}

//and(and-attr(zero-one(attr)))
TEST(and_and_zero_one_attr) {
	check_nt("X : TA1 (T1 T2 (a=T3)? T) TA2 ;",
		"X{c:X} : TA1 A:0({u:tp} : T1 T2 A:1({u:tp} : T3 [copy] | [void]) T [r:2]) TA2 [c(a=1)]");
}

//and(and-attr(and-attr(attr)))
TEST(and_and_and_attr) {
	check_nt("X : TA1 (T1 T2 (T a=T3 T)) TA2 ;",
		"X{c:X} : TA1 A:0({u:tp} : T1 T2 A:1({u:tp} : T T3 T [r:1]) [r:2]) TA2 [c(a=1)]");
}

//and(or(attr,attr))
TEST(and_or_attr_attr) {
	check_nt("X : TA1 (a=T1 | a=T2) TA2 ;", "X{c:X} : TA1 A:0({c:X} : T1 [c(a=0)] | T2 [c(a=0)]) TA2 [c(this=1)]");
}

//and(or(attr,or(attr)))
TEST(and_or_attr_or_attr) {
	check_nt("X : TA1 (a=T1 | (TA3 | a=T2)) TA2 ;",
		"X{c:X} : TA1 A:0({c:X} : T1 [c(a=0)] | A:1({c:X} : TA3 [void] | T2 [c(a=0)]) [copy]) TA2 [c(this=1)]");
}

//and(or(attr,zero-one(attr))
TEST(and_or_attr_zero_one_attr) {
	check_nt("X : TA1 (a=T1 | (a=T2)?) TA2 ;",
		"X{c:X} : TA1 A:0({c:X} : T1 [c(a=0)] | A:1({c:X} : T2 [c(a=0)] | [void]) [copy]) TA2 [c(this=1)]");
}

//and(or(attr,and-class(attr))
TEST(and_or_attr_and_attr) {
	check_nt("X : (a=T1 | (a=T2 T T3)) TA2 T ;",
		"X{c:X} : A:0({c:X} : T1 [c(a=0)] | T2 T T3 [c(a=0)]) TA2 T [c(this=0)]");
}

//and(or(or(attr),or(attr))
TEST(and_or_or_attr_or_attr) {
	check_nt("X : T T T ((TA3 | a=T1) | (a=T2 | T)) TA2 ;",
		"X{c:X} : T T T A:0({c:X} : A:1({c:X} : TA3 [void] "
		"| T1 [c(a=0)]) [copy] | A:2({c:X} : T2 [c(a=0)] | T [void]) [copy]) TA2 [c(this=3)]");
}

//and(or(or(attr),zero-one(attr))
TEST(and_or_or_attr_zero_one_attr) {
	check_nt("X : TA1 ((TA3 | a=T1) | (a=T2 | T)) TA2 ;",
		"X{c:X} : TA1 A:0({c:X} : A:1({c:X} : TA3 [void] "
		"| T1 [c(a=0)]) [copy] | A:2({c:X} : T2 [c(a=0)] | T [void]) [copy]) TA2 [c(this=1)]");
}

//and(or(or(attr),and-class(attr))
TEST(and_or_or_attr_and_attr) {
	check_nt("X : TA1 ((a=T1 | T) | (T a=T2 TA3)) TA2 ;",
		"X{c:X} : TA1 A:0({c:X} : A:1({c:X} : T1 [c(a=0)] | T [void]) [copy] | T T2 TA3 [c(a=1)]) TA2 [c(this=1)]");
}

//and(or(zero-one(attr),zero-one(attr))
TEST(and_or_zero_one_attr_zero_one_attr) {
	check_nt("X : TA3 TA1 ((a=T1)? | (a=T2)?) TA2 ;",
		"X{c:X} : TA3 TA1 A:0({c:X} : A:1({c:X} : T1 [c(a=0)] | [void]) [copy] "
		"| A:2({c:X} : T2 [c(a=0)] | [void]) [copy]) TA2 [c(this=2)]");
}

//and(or(zero-one(attr),and-class(attr))
TEST(and_or_zero_one_attr_and_attr) {
	check_nt("X : TA1 ((a=T1)? | (T TA2 a=T2 T)) TA2 ;",
		"X{c:X} : TA1 A:0({c:X} : A:1({c:X} : T1 [c(a=0)] | [void]) [copy] | T TA2 T2 T [c(a=2)]) TA2 [c(this=1)]");
}

//and(or(and-class(attr),and-class(attr))
TEST(and_or_and_attr_and_attr) {
	check_nt("X : TA1 ((T a=T1 TA2 T) | (T TA2 a=T2 T)) TA2 ;",
		"X{c:X} : TA1 A:0({c:X} : T T1 TA2 T [c(a=1)] | T TA2 T2 T [c(a=2)]) TA2 [c(this=1)]");
}

//and(or(attr,attr2))
TEST(and_or_attr_attr2) {
	check_nt("X : TA1 TA3 (a=T1 | b=T2) TA2 ;", "X{c:X} : TA1 TA3 A:0({c:X} : T1 [c(a=0)] | T2 [c(b=0)]) TA2 [c(this=2)]");
}

//and(attr,attr2)
TEST(and_attr_attr2) {
	check_nt("X : a=TA1 T b=TA2 ;", "X{c:X} : TA1 T TA2 [c(a=0 b=2)]");
}

//and(attr,or(attr2))
TEST(and_attr_or_attr2) {
	check_nt("X : a=TA1 T (b=TA2 | TA3) ;", "X{c:X} : TA1 T A:0({u:tp2} : TA2 [copy] | TA3 [void]) [c(a=0 b=2)]");
}

//and(attr,zero-one(attr2))
TEST(and_attr_zero_one_attr2) {
	check_nt("X : a=TA1 T (b=TA2)? ;", "X{c:X} : TA1 T A:0({u:tp2} : TA2 [copy] | [void]) [c(a=0 b=2)]");
}

//and(attr,and-attr(attr2))
TEST(and_attr_and_attr2) {
	check_nt("X : a=TA1 T (TA2 b=TA2 T) ;", "X{c:X} : TA1 T A:0({u:tp2} : TA2 TA2 T [r:1]) [c(a=0 b=2)]");
}

//and(attr,and-part-class(attr2,attr3))
TEST(and_attr_and_attr2_attr3) {
	check_nt("X : TA3 a=TA1 (TA2 b=TA2 T c=T3) ;", "X{c:X} : TA3 TA1 A:0({p} : TA2 TA2 T T3 [p(b=1 c=3)]) [c(a=1 p=2)]");
}

//and(or(attr),or(attr2))
TEST(and_or_attr_or_attr2) {
	check_nt("X : TA3 (a=TA1 | T1) T1 (TA2 | b=TA2) T ;",
		"X{c:X} : TA3 A:0({u:tp1} : TA1 [copy] | T1 [void]) T1 A:1({u:tp2} : TA2 [void] | TA2 [copy]) T [c(a=1 b=3)]");
}

//and(or(attr,zero-one(attr2))
TEST(and_or_attr_zero_one_attr2) {
	check_nt("X : TA3 (a=TA1 | (b=TA2)?) TA3 ;",
		"X{c:X} : TA3 A:0({c:X} : TA1 [c(a=0)] | A:1({c:X} : TA2 [c(b=0)] | [void]) [copy]) TA3 [c(this=1)]");
}

//and(or(attr),zero-one(attr2)))
TEST(and_or_attr_c_zero_one_attr2) {
	check_nt("X : TA3 (a=TA1 | TA2) T1 T2 T3 (b=TA2)? TA3 ;",
		"X{c:X} : TA3 A:0({u:tp1} : TA1 [copy] | TA2 [void]) T1 T2 T3 A:1({u:tp2} : TA2 [copy] | [void]) TA3 [c(a=1 b=5)]");
}

//and(or(attr),and-attr(attr2))
TEST(and_or_attr_and_attr2) {
	check_nt("X : TA3 (a=TA1 | (b=TA2)?) TA3 ;",
		"X{c:X} : TA3 A:0({c:X} : TA1 [c(a=0)] | A:1({c:X} : TA2 [c(b=0)] | [void]) [copy]) TA3 [c(this=1)]");
}

//and(or(attr),and-part-class(attr2,attr3))
TEST(and_or_attr_and_attr2_attr3) {
	check_nt("X : TA3 (a=TA1 | TA1) TA3 (b=T2 c=T3) TA3 ;",
		"X{c:X} : TA3 A:0({u:tp1} : TA1 [copy] | TA1 [void]) TA3 "
		"A:1({p} : T2 T3 [p(b=0 c=1)]) TA3 [c(a=1 p=3)]");
}

//and(zero-one(attr),zero-one(attr2))
TEST(and_zero_one_attr_zero_one_attr2) {
	check_nt("X : TA3 (a=TA1)? TA3 (b=T2)? TA3 ;",
		"X{c:X} : TA3 A:0({u:tp1} : TA1 [copy] | [void]) TA3 A:1({u:tp} : T2 [copy] | [void]) TA3 [c(a=1 b=3)]");
}

//and(zero-one(attr),and-attr(attr2))
TEST(and_zero_one_attr_and_attr2) {
	check_nt("X : TA3 (a=TA1)? TA3 (T1 b=T2 T3) TA3 ;",
		"X{c:X} : TA3 A:0({u:tp1} : TA1 [copy] | [void]) TA3 A:1({u:tp} : T1 T2 T3 [r:1]) TA3 [c(a=1 b=3)]");
}

//and(zero-one(attr),and-part-class(attr2,attr3))
TEST(and_zero_one_attr_and_attr2_attr3) {
	check_nt("X : TA3 (a=TA1)? TA3 (T b=T2 T c=T3) TA3 ;",
		"X{c:X} : TA3 A:0({u:tp1} : TA1 [copy] | [void]) TA3 A:1({p} : T T2 T T3 [p(b=1 c=3)]) TA3 [c(a=1 p=3)]");
}

//and(and-attr(attr),and-attr(attr2))
TEST(and_and_attr_and_attr2) {
	check_nt("X : TA3 (T a=TA1 T) TA3 (T b=T2 T) TA3 ;",
		"X{c:X} : TA3 A:0({u:tp1} : T TA1 T [r:1]) TA3 A:1({u:tp} : T T2 T [r:1]) TA3 [c(a=1 b=3)]");
}

//and(and-attr(attr),and-part-class(attr2,attr3))
TEST(and_and_attr_and_attr2_attr3) {
	check_nt("X : TA3 (T a=TA1 T) TA3 (T b=T2 T c=T3 T) TA3 ;",
		"X{c:X} : TA3 A:0({u:tp1} : T TA1 T [r:1]) TA3 A:1({p} : T T2 T T3 T [p(b=1 c=3)]) TA3 [c(a=1 p=3)]");
}

//and(and-part-class(attr,attr2),and-part-class(attr3,attr4))
TEST(and_and_attr_attr2_and_attr3_attr4) {
	check_nt("X : TA3 (T a=TA1 T T1 T2 b=T3) TA3 (T c=T2 T d=T3 T) TA3 ;",
		"X{c:X} : TA3 A:0({p} : T TA1 T T1 T2 T3 [p(a=1 b=5)]) TA3 A:1({p} : T T2 T T3 T [p(c=1 d=3)]) TA3 [c(p=1 p=3)]");
}

//and(and-class(attr,attr2))
TEST(and_and_attr_attr2) {
	check_nt("X : TA3 (T a=TA1 T T1 T2 b=T3) TA3 ;",
		"X{c:X} : TA3 A:0({c:X} : T TA1 T T1 T2 T3 [c(a=1 b=5)]) TA3 [c(this=1)]");
}

//Misc.

TEST(zero_many_void) {
	check_nt("X : T* ;", "X{void} : A:0({void} : A:0 T [void] | T [void]) [void] | [void]");
}

TEST(one_many_void) {
	check_nt("X : T+ ;", "X{void} : X T [void] | T [void]");
}

TEST(unreferenced_tokens_converted) {
	ConvResAutoPtr conv_res = process_grammar("%token T1; %token T2; %token T3; @X : T2 ;");
	assertEquals(3, conv_res->get_name_tokens().size());
	
	std::vector<std::string> token_names;
	for (std::size_t i = 0, n = conv_res->get_name_tokens().size(); i < n; ++i) {
		token_names.push_back(conv_res->get_name_tokens()[i]->get_name().str());
	}
	std::sort(token_names.begin(), token_names.end());
	assertEquals("T1", token_names[0]);
	assertEquals("T2", token_names[1]);
	assertEquals("T3", token_names[2]);
}

TEST(unreferenced_types_converted) {
	ConvResAutoPtr conv_res = process_grammar("%token T1 {Type1}; %token T2 {Type2}; %type Type3; @X : T1 ;");
	
	std::vector<std::string> type_names;
	for (std::size_t i = 0, n = conv_res->get_primitive_types().size(); i < n; ++i) {
		const ns::PrimitiveTypeDescriptor* type = conv_res->get_primitive_types()[i];
		if (!type->get_primitive_type()->is_system()) {
			type_names.push_back(type->get_primitive_type()->get_name().str());
		}
	}
	assertEquals(3, type_names.size());

	std::sort(type_names.begin(), type_names.end());
	assertEquals("Type1", type_names[0]);
	assertEquals("Type2", type_names[1]);
	assertEquals("Type3", type_names[2]);
}

TEST(unreferenced_system_types_converted) {
	ConvResAutoPtr conv_res = process_grammar("%token T1; @X : T1 ;");
	
	std::vector<std::string> type_names;
	for (std::size_t i = 0, n = conv_res->get_primitive_types().size(); i < n; ++i) {
		const ns::PrimitiveTypeDescriptor* type = conv_res->get_primitive_types()[i];
		if (type->get_primitive_type()->is_system()) {
			type_names.push_back(type->get_primitive_type()->get_name().str());
		}
	}

	assertTrue(std::find(type_names.begin(), type_names.end(), "const_int") != type_names.end());
	assertTrue(std::find(type_names.begin(), type_names.end(), "const_bool") != type_names.end());
	assertTrue(std::find(type_names.begin(), type_names.end(), "const_str") != type_names.end());
}

}
